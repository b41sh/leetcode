# 贪心算法(greedy)

做当前最佳的选择，通过局部最优选择产生全局最优解。不能保证总能得到最优解，但是对很多问题可以求出最优解。

贪心算法步骤

1. 决定问题的最优子结构
2. 设计一个递归解
3. 证明在递归的任一阶段，最优选择之一总是贪心选择。那么贪心选择总是安全的
4. 证明通过做贪心选择，所有子问题(除一个意外)都为空
5. 设计出一个实现贪心策略的递归算法
6. 将递归问题转换成迭代算法

贪心算法得到最优解需要满足两个条件：贪心选择性质、最优子结构。

* 贪心选择性质：一个全局最优解可以通过局部最优解来得到。当考虑如何做选择时，我们只考虑对当前问题最佳的选择而不考虑子问题的结果。
* 最优子结构：全局最优解包含子问题的最优解。

贪心算法和动态规划的区别：在动态规划中，每一步都要做出选择，但是这些选择都依赖于子问题的解。因此，解动态规划问题一般是自底向上，由子问题到问题。在贪心算法中，我们总是做出当前的最好选择，而这些选择都不是依赖子问题，选择后再解决选择之后出现的子问题。因此，解贪心算法问题一般是自顶向下，一个一个地做出贪心选择。


## [134. Gas Station](https://leetcode.com/problems/gas-station/)

如果总油量小于总消耗，肯定不能走完。如果总油量大于等于总消耗，则肯定有一个位置开始可以走完。从0开始累加油量减去消耗的值，如果在某天节点小于0，则说明开始节点只能是下一个节点之后的位置。

## [135. Candy](https://leetcode.com/problems/candy/description/)

初始化，所有数量的值记录为1，从左向右遍历，如果右边大于左边，则右边的值记录为左边的值加一，再从右到左遍历，如果左边比右边大同时之前记录的数量左边小于等于右边，则左边的值记录为右边的值加一。

